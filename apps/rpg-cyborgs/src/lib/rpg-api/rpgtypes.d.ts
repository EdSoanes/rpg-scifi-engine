/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/api/rpg/{system}/{archetype}/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    system: string;
                    archetype: string;
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Server.RpgResponse_String"];
                        "text/json": components["schemas"]["Server.RpgResponse_String"];
                        "text/plain": components["schemas"]["Server.RpgResponse_String"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/rpg/{system}/action/args": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    system: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["Server.RpgRequest_ActionStepArgs"];
                    "text/json": components["schemas"]["Server.RpgRequest_ActionStepArgs"];
                    "application/*+json": components["schemas"]["Server.RpgRequest_ActionStepArgs"];
                    "application/json-patch+json": components["schemas"]["Server.RpgRequest_ActionStepArgs"];
                };
            };
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Server.RpgResponse_RpgArg[]"];
                        "text/json": components["schemas"]["Server.RpgResponse_RpgArg[]"];
                        "text/plain": components["schemas"]["Server.RpgResponse_RpgArg[]"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/rpg/{system}/action/autocomplete": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    system: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["Server.RpgRequest_ActivityComplete"];
                    "text/json": components["schemas"]["Server.RpgRequest_ActivityComplete"];
                    "application/*+json": components["schemas"]["Server.RpgRequest_ActivityComplete"];
                    "application/json-patch+json": components["schemas"]["Server.RpgRequest_ActivityComplete"];
                };
            };
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Server.RpgResponse_Action"];
                        "text/json": components["schemas"]["Server.RpgResponse_Action"];
                        "text/plain": components["schemas"]["Server.RpgResponse_Action"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/rpg/{system}/action/complete": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    system: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["Server.RpgRequest_ActivityComplete"];
                    "text/json": components["schemas"]["Server.RpgRequest_ActivityComplete"];
                    "application/*+json": components["schemas"]["Server.RpgRequest_ActivityComplete"];
                    "application/json-patch+json": components["schemas"]["Server.RpgRequest_ActivityComplete"];
                };
            };
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Server.RpgResponse_Action"];
                        "text/json": components["schemas"]["Server.RpgResponse_Action"];
                        "text/plain": components["schemas"]["Server.RpgResponse_Action"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/rpg/{system}/action/cost": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    system: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["Server.RpgRequest_ActionStepRun"];
                    "text/json": components["schemas"]["Server.RpgRequest_ActionStepRun"];
                    "application/*+json": components["schemas"]["Server.RpgRequest_ActionStepRun"];
                    "application/json-patch+json": components["schemas"]["Server.RpgRequest_ActionStepRun"];
                };
            };
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Server.RpgResponse_Action"];
                        "text/json": components["schemas"]["Server.RpgResponse_Action"];
                        "text/plain": components["schemas"]["Server.RpgResponse_Action"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/rpg/{system}/action/initiate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    system: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["Server.RpgRequest_InitiateAction"];
                    "text/json": components["schemas"]["Server.RpgRequest_InitiateAction"];
                    "application/*+json": components["schemas"]["Server.RpgRequest_InitiateAction"];
                    "application/json-patch+json": components["schemas"]["Server.RpgRequest_InitiateAction"];
                };
            };
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Server.RpgResponse_Activity"];
                        "text/json": components["schemas"]["Server.RpgResponse_Activity"];
                        "text/plain": components["schemas"]["Server.RpgResponse_Activity"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/rpg/{system}/action/outcome": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    system: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["Server.RpgRequest_ActionStepRun"];
                    "text/json": components["schemas"]["Server.RpgRequest_ActionStepRun"];
                    "application/*+json": components["schemas"]["Server.RpgRequest_ActionStepRun"];
                    "application/json-patch+json": components["schemas"]["Server.RpgRequest_ActionStepRun"];
                };
            };
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Server.RpgResponse_Action"];
                        "text/json": components["schemas"]["Server.RpgResponse_Action"];
                        "text/plain": components["schemas"]["Server.RpgResponse_Action"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/rpg/{system}/action/perform": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    system: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["Server.RpgRequest_ActionStepRun"];
                    "text/json": components["schemas"]["Server.RpgRequest_ActionStepRun"];
                    "application/*+json": components["schemas"]["Server.RpgRequest_ActionStepRun"];
                    "application/json-patch+json": components["schemas"]["Server.RpgRequest_ActionStepRun"];
                };
            };
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Server.RpgResponse_Action"];
                        "text/json": components["schemas"]["Server.RpgResponse_Action"];
                        "text/plain": components["schemas"]["Server.RpgResponse_Action"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/rpg/{system}/action/reset": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    system: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["Server.RpgRequest_ActivityComplete"];
                    "text/json": components["schemas"]["Server.RpgRequest_ActivityComplete"];
                    "application/*+json": components["schemas"]["Server.RpgRequest_ActivityComplete"];
                    "application/json-patch+json": components["schemas"]["Server.RpgRequest_ActivityComplete"];
                };
            };
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Server.RpgResponse_Action"];
                        "text/json": components["schemas"]["Server.RpgResponse_Action"];
                        "text/plain": components["schemas"]["Server.RpgResponse_Action"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/rpg/{system}/describe": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    system: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["Server.RpgRequest_DescribeProp"];
                    "text/json": components["schemas"]["Server.RpgRequest_DescribeProp"];
                    "application/*+json": components["schemas"]["Server.RpgRequest_DescribeProp"];
                    "application/json-patch+json": components["schemas"]["Server.RpgRequest_DescribeProp"];
                };
            };
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Server.RpgResponse_PropDescription"];
                        "text/json": components["schemas"]["Server.RpgResponse_PropDescription"];
                        "text/plain": components["schemas"]["Server.RpgResponse_PropDescription"];
                    };
                };
                /** @description Bad Request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/rpg/{system}/entities": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    system: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Server.RpgContent"][];
                        "text/json": components["schemas"]["Server.RpgContent"][];
                        "text/plain": components["schemas"]["Server.RpgContent"][];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/rpg/{system}/entities/props/override": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    system: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["Server.RpgRequest_OverrideBaseValue"];
                    "text/json": components["schemas"]["Server.RpgRequest_OverrideBaseValue"];
                    "application/*+json": components["schemas"]["Server.RpgRequest_OverrideBaseValue"];
                    "application/json-patch+json": components["schemas"]["Server.RpgRequest_OverrideBaseValue"];
                };
            };
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Server.RpgResponse_Boolean"];
                        "text/json": components["schemas"]["Server.RpgResponse_Boolean"];
                        "text/plain": components["schemas"]["Server.RpgResponse_Boolean"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/rpg/{system}/modset": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    system: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["Server.RpgRequest_ModSet"];
                    "text/json": components["schemas"]["Server.RpgRequest_ModSet"];
                    "application/*+json": components["schemas"]["Server.RpgRequest_ModSet"];
                    "application/json-patch+json": components["schemas"]["Server.RpgRequest_ModSet"];
                };
            };
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Server.RpgResponse_Boolean"];
                        "text/json": components["schemas"]["Server.RpgResponse_Boolean"];
                        "text/plain": components["schemas"]["Server.RpgResponse_Boolean"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/rpg/{system}/modset/describe": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    system: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["Server.RpgRequest_DescribeModSet"];
                    "text/json": components["schemas"]["Server.RpgRequest_DescribeModSet"];
                    "application/*+json": components["schemas"]["Server.RpgRequest_DescribeModSet"];
                    "application/json-patch+json": components["schemas"]["Server.RpgRequest_DescribeModSet"];
                };
            };
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Server.RpgResponse_ModSetDescription"];
                        "text/json": components["schemas"]["Server.RpgResponse_ModSetDescription"];
                        "text/plain": components["schemas"]["Server.RpgResponse_ModSetDescription"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/rpg/{system}/state": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    system: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["Server.RpgRequest_SetState"];
                    "text/json": components["schemas"]["Server.RpgRequest_SetState"];
                    "application/*+json": components["schemas"]["Server.RpgRequest_SetState"];
                    "application/json-patch+json": components["schemas"]["Server.RpgRequest_SetState"];
                };
            };
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Server.RpgResponse_String"];
                        "text/json": components["schemas"]["Server.RpgResponse_String"];
                        "text/plain": components["schemas"]["Server.RpgResponse_String"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/rpg/{system}/state/describe": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    system: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["Server.RpgRequest_DescribeState"];
                    "text/json": components["schemas"]["Server.RpgRequest_DescribeState"];
                    "application/*+json": components["schemas"]["Server.RpgRequest_DescribeState"];
                    "application/json-patch+json": components["schemas"]["Server.RpgRequest_DescribeState"];
                };
            };
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Server.RpgResponse_ModSetDescription"];
                        "text/json": components["schemas"]["Server.RpgResponse_ModSetDescription"];
                        "text/plain": components["schemas"]["Server.RpgResponse_ModSetDescription"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/rpg/{system}/time": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    system: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["Server.RpgRequest_PointInTime"];
                    "text/json": components["schemas"]["Server.RpgRequest_PointInTime"];
                    "application/*+json": components["schemas"]["Server.RpgRequest_PointInTime"];
                    "application/json-patch+json": components["schemas"]["Server.RpgRequest_PointInTime"];
                };
            };
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Server.RpgResponse_PointInTime"];
                        "text/json": components["schemas"]["Server.RpgResponse_PointInTime"];
                        "text/plain": components["schemas"]["Server.RpgResponse_PointInTime"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        "Activities.Action": {
            readonly actionTemplateName: string;
            /** Format: int32 */
            readonly actionNo: number;
            readonly actionOwnerId: string;
            readonly initiatorId: string;
            readonly actionArgs: (components["schemas"]["Reflection.Args.DefaultArg"] | components["schemas"]["Reflection.Args.DiceArg"] | components["schemas"]["Reflection.Args.IntegerArg"] | components["schemas"]["Reflection.Args.RpgObjectArg"])[];
            readonly isCostDone: boolean;
            readonly isPerformDone: boolean;
            readonly isOutcomeDone: boolean;
            readonly costModSet: components["schemas"]["Mods.ModSet"] | components["schemas"]["Mods.ModSets.StateModSet"] | components["schemas"]["Mods.ModSets.SyncedModSet"] | components["schemas"]["Mods.ModSets.TimedModSet"] | components["schemas"]["Mods.ModSets.TurnModSet"];
            readonly outcomeModSet: components["schemas"]["Mods.ModSet"] | components["schemas"]["Mods.ModSets.StateModSet"] | components["schemas"]["Mods.ModSets.SyncedModSet"] | components["schemas"]["Mods.ModSets.TimedModSet"] | components["schemas"]["Mods.ModSets.TurnModSet"];
            readonly outcomeStates: components["schemas"]["States.StateRef"][];
            readonly outcomeActions: components["schemas"]["Activities.ActionRef"][];
            status: components["schemas"]["Activities.ActionStatus"];
            readonly isStarted: boolean;
            readonly isComplete: boolean;
        } & components["schemas"]["RpgObject"];
        "Activities.ActionRef": {
            activityId: string;
            readonly actionTemplateOwnerId: string;
            readonly actionTemplateName: string;
            optional: boolean;
        };
        /** @enum {string} */
        "Activities.ActionStatus": "NotStarted" | "CanAutoComplete" | "Started" | "CanComplete" | "Completed";
        "Activities.ActionTemplate_Actor": {
            readonly id: string;
            readonly name: string;
            readonly classification: string;
            readonly ownerId: string;
            readonly ownerArchetype: string;
            readonly actionArgs: (components["schemas"]["Reflection.Args.DefaultArg"] | components["schemas"]["Reflection.Args.DiceArg"] | components["schemas"]["Reflection.Args.IntegerArg"] | components["schemas"]["Reflection.Args.RpgObjectArg"])[];
            canPerformMethod: components["schemas"]["Reflection.RpgMethod_ActionTemplate_Boolean"];
            costMethod: components["schemas"]["Reflection.RpgMethod_ActionTemplate_Boolean"];
            performMethod: components["schemas"]["Reflection.RpgMethod_ActionTemplate_Boolean"];
            outcomeMethod: components["schemas"]["Reflection.RpgMethod_ActionTemplate_Boolean"];
            readonly isPerformable: boolean;
        };
        "Activities.ActionTemplate_MeleeWeapon": {
            readonly id: string;
            readonly name: string;
            readonly classification: string;
            readonly ownerId: string;
            readonly ownerArchetype: string;
            readonly actionArgs: (components["schemas"]["Reflection.Args.DefaultArg"] | components["schemas"]["Reflection.Args.DiceArg"] | components["schemas"]["Reflection.Args.IntegerArg"] | components["schemas"]["Reflection.Args.RpgObjectArg"])[];
            canPerformMethod: components["schemas"]["Reflection.RpgMethod_ActionTemplate_Boolean"];
            costMethod: components["schemas"]["Reflection.RpgMethod_ActionTemplate_Boolean"];
            performMethod: components["schemas"]["Reflection.RpgMethod_ActionTemplate_Boolean"];
            outcomeMethod: components["schemas"]["Reflection.RpgMethod_ActionTemplate_Boolean"];
            readonly isPerformable: boolean;
        };
        "Activities.ActionTemplate_RangedWeapon": {
            readonly id: string;
            readonly name: string;
            readonly classification: string;
            readonly ownerId: string;
            readonly ownerArchetype: string;
            readonly actionArgs: (components["schemas"]["Reflection.Args.DefaultArg"] | components["schemas"]["Reflection.Args.DiceArg"] | components["schemas"]["Reflection.Args.IntegerArg"] | components["schemas"]["Reflection.Args.RpgObjectArg"])[];
            canPerformMethod: components["schemas"]["Reflection.RpgMethod_ActionTemplate_Boolean"];
            costMethod: components["schemas"]["Reflection.RpgMethod_ActionTemplate_Boolean"];
            performMethod: components["schemas"]["Reflection.RpgMethod_ActionTemplate_Boolean"];
            outcomeMethod: components["schemas"]["Reflection.RpgMethod_ActionTemplate_Boolean"];
            readonly isPerformable: boolean;
        };
        "Activities.ActionTemplate_RpgEntity": {
            readonly id: string;
            readonly name: string;
            readonly classification: string;
            readonly ownerId: string;
            readonly ownerArchetype: string;
            readonly actionArgs: (components["schemas"]["Reflection.Args.DefaultArg"] | components["schemas"]["Reflection.Args.DiceArg"] | components["schemas"]["Reflection.Args.IntegerArg"] | components["schemas"]["Reflection.Args.RpgObjectArg"])[];
            canPerformMethod: components["schemas"]["Reflection.RpgMethod_ActionTemplate_Boolean"];
            costMethod: components["schemas"]["Reflection.RpgMethod_ActionTemplate_Boolean"];
            performMethod: components["schemas"]["Reflection.RpgMethod_ActionTemplate_Boolean"];
            outcomeMethod: components["schemas"]["Reflection.RpgMethod_ActionTemplate_Boolean"];
            readonly isPerformable: boolean;
        };
        "Activities.Activity": {
            /** Format: int32 */
            activityNo: number;
            readonly actions: components["schemas"]["Activities.Action"][];
            readonly canAutoComplete: boolean;
            /** Format: int32 */
            readonly currentActionNo: number;
        } & components["schemas"]["RpgObject"];
        "Behaviors.Add": components["schemas"]["Behaviors.BaseBehavior"];
        "Behaviors.BaseBehavior": {
            scope: components["schemas"]["Mods.ModScope"];
        };
        "Behaviors.Combine": components["schemas"]["Behaviors.BaseBehavior"];
        "Behaviors.ExpiresOn": {
            value: components["schemas"]["Values.Dice"];
        } & components["schemas"]["Behaviors.BaseBehavior"];
        "Behaviors.Highest": components["schemas"]["Behaviors.BaseBehavior"];
        "Behaviors.Replace": components["schemas"]["Behaviors.BaseBehavior"];
        "Behaviors.Threshold": {
            /** Format: int32 */
            min: number;
            /** Format: int32 */
            max: number;
        } & components["schemas"]["Behaviors.BaseBehavior"];
        "Cyborgs.Actions.ArmourCheck": components["schemas"]["Activities.ActionTemplate_Actor"];
        "Cyborgs.Actions.MeleeAttack": components["schemas"]["Activities.ActionTemplate_MeleeWeapon"];
        "Cyborgs.Actions.MeleeParry": components["schemas"]["Activities.ActionTemplate_Actor"];
        "Cyborgs.Actions.RangedAttack": components["schemas"]["Activities.ActionTemplate_RangedWeapon"];
        "Cyborgs.Actions.TakeDamage": components["schemas"]["Activities.ActionTemplate_Actor"];
        "Cyborgs.Actions.TakeInjury": components["schemas"]["Activities.ActionTemplate_Actor"];
        "Cyborgs.Actions.Transfer": components["schemas"]["Activities.ActionTemplate_RpgEntity"];
        "Cyborgs.Actor": {
            expiry: components["schemas"]["Time.LifecycleExpiry"];
            modSets: {
                [key: string]: components["schemas"]["Mods.ModSet"] | components["schemas"]["Mods.ModSets.StateModSet"] | components["schemas"]["Mods.ModSets.SyncedModSet"] | components["schemas"]["Mods.ModSets.TimedModSet"] | components["schemas"]["Mods.ModSets.TurnModSet"];
            };
            props: {
                [key: string]: components["schemas"]["Props.Prop"];
            };
            states: {
                [key: string]: components["schemas"]["Cyborgs.States.Aiming"] | components["schemas"]["Cyborgs.States.Exhausted"] | components["schemas"]["Cyborgs.States.Firing"] | components["schemas"]["Cyborgs.States.MeleeAttacked"] | components["schemas"]["Cyborgs.States.MeleeAttacking"] | components["schemas"]["Cyborgs.States.Moving"] | components["schemas"]["Cyborgs.States.Parrying"] | components["schemas"]["Cyborgs.States.RangedAttacking"] | components["schemas"]["Cyborgs.States.VeryFast"] | components["schemas"]["Cyborgs.Conditions.Attachable"] | components["schemas"]["Cyborgs.Conditions.Bleeding"] | components["schemas"]["Cyborgs.Conditions.Dead"] | components["schemas"]["Cyborgs.Conditions.Dying"] | components["schemas"]["Cyborgs.Conditions.Fixable"] | components["schemas"]["Cyborgs.Conditions.Pain"] | components["schemas"]["Cyborgs.Conditions.Repairable"] | components["schemas"]["Cyborgs.Conditions.Replaceable"] | components["schemas"]["Cyborgs.Conditions.Shock"] | components["schemas"]["Cyborgs.Conditions.Treatable"] | components["schemas"]["Cyborgs.Conditions.Unconscious"] | components["schemas"]["Cyborgs.Conditions.Unusable"];
            };
            readonly id: string;
            readonly ownerId?: string | null;
            readonly archetype: string;
            readonly name: string;
            readonly archetypes: string[];
            readonly actionTemplates: {
                [key: string]: components["schemas"]["Cyborgs.Skills.Movement.Run"] | components["schemas"]["Cyborgs.Skills.Combat.Aim"] | components["schemas"]["Cyborgs.Actions.ArmourCheck"] | components["schemas"]["Cyborgs.Actions.MeleeAttack"] | components["schemas"]["Cyborgs.Actions.MeleeParry"] | components["schemas"]["Cyborgs.Actions.RangedAttack"] | components["schemas"]["Cyborgs.Actions.TakeDamage"] | components["schemas"]["Cyborgs.Actions.TakeInjury"] | components["schemas"]["Cyborgs.Actions.Transfer"];
            };
            readonly strength: components["schemas"]["Cyborgs.Components.PropValue"];
            readonly agility: components["schemas"]["Cyborgs.Components.PropValue"];
            readonly health: components["schemas"]["Cyborgs.Components.PropValue"];
            readonly brains: components["schemas"]["Cyborgs.Components.PropValue"];
            readonly insight: components["schemas"]["Cyborgs.Components.PropValue"];
            readonly charisma: components["schemas"]["Cyborgs.Components.PropValue"];
            /** Format: int32 */
            readonly focusPoints: number;
            /** Format: int32 */
            readonly currentFocusPoints: number;
            /** Format: int32 */
            readonly luckPoints: number;
            /** Format: int32 */
            readonly currentLuckPoints: number;
            /** Format: int32 */
            readonly staminaPoints: number;
            /** Format: int32 */
            readonly currentStaminaPoints: number;
            /** Format: int32 */
            readonly lifePoints: number;
            /** Format: int32 */
            readonly currentLifePoints: number;
            /** Format: int32 */
            readonly actionPoints: number;
            /** Format: int32 */
            readonly currentActionPoints: number;
            readonly head: components["schemas"]["Cyborgs.BodyPart"];
            readonly torso: components["schemas"]["Cyborgs.BodyPart"];
            readonly leftArm: components["schemas"]["Cyborgs.BodyPart"];
            readonly rightArm: components["schemas"]["Cyborgs.BodyPart"];
            readonly leftLeg: components["schemas"]["Cyborgs.BodyPart"];
            readonly rightLeg: components["schemas"]["Cyborgs.BodyPart"];
            readonly reactions: components["schemas"]["Cyborgs.Components.PropValue"];
            readonly defence: components["schemas"]["Cyborgs.Components.PropValue"];
            readonly armourRating: components["schemas"]["Cyborgs.Components.PropValue"];
            readonly unarmedDamageBonus: components["schemas"]["Cyborgs.Components.PropValue"];
            readonly parryDamageReduction: components["schemas"]["Cyborgs.Components.PropValue"];
            readonly rangedAttack: components["schemas"]["Cyborgs.Components.PropValue"];
            readonly rangedAimBonus: components["schemas"]["Cyborgs.Components.PropValue"];
            readonly meleeAttack: components["schemas"]["Cyborgs.Components.PropValue"];
            readonly hands: components["schemas"]["RpgContainer"];
            readonly wearing: components["schemas"]["RpgContainer"];
        };
        "Cyborgs.Armour": {
            /** Format: int32 */
            readonly armourRating: number;
            /** Format: int32 */
            readonly currentArmourRating: number;
            /** Format: int32 */
            readonly defenceModifier: number;
        } & components["schemas"]["RpgEntity"];
        "Cyborgs.BodyPart": {
            /** Format: int32 */
            readonly injurySeverity: number;
            readonly injuries: components["schemas"]["Cyborgs.Injury"][];
            bodyPartType: components["schemas"]["Cyborgs.BodyPartType"];
        } & components["schemas"]["RpgComponent"];
        /** @enum {string} */
        "Cyborgs.BodyPartType": "Limb" | "Torso" | "Head";
        "Cyborgs.Components.PropValue": {
            /** Format: int32 */
            value: number;
            /** Format: int32 */
            readonly initValue: number;
            /** Format: int32 */
            readonly baseValue: number;
        } & components["schemas"]["RpgComponent"];
        "Cyborgs.Conditions.Attachable": components["schemas"]["Cyborgs.Conditions.Condition_BodyPart"];
        "Cyborgs.Conditions.Bleeding": components["schemas"]["Cyborgs.Conditions.Condition_BodyPart"];
        "Cyborgs.Conditions.Condition_Actor": {
            expiry: components["schemas"]["Time.LifecycleExpiry"];
            readonly id: string;
            readonly name: string;
            readonly classification: string;
            readonly ownerId: string;
            readonly ownerArchetype?: string | null;
            readonly isPlayerVisible: boolean;
            readonly isOn: boolean;
            readonly isOnTimed: boolean;
            readonly isOnManually: boolean;
            readonly isOnConditionally: boolean;
            removeOnActions: string[];
        };
        "Cyborgs.Conditions.Condition_BodyPart": {
            expiry: components["schemas"]["Time.LifecycleExpiry"];
            readonly id: string;
            readonly name: string;
            readonly classification: string;
            readonly ownerId: string;
            readonly ownerArchetype?: string | null;
            readonly isPlayerVisible: boolean;
            readonly isOn: boolean;
            readonly isOnTimed: boolean;
            readonly isOnManually: boolean;
            readonly isOnConditionally: boolean;
            removeOnActions: string[];
        };
        "Cyborgs.Conditions.Dead": components["schemas"]["Cyborgs.Conditions.Condition_BodyPart"];
        "Cyborgs.Conditions.Dying": components["schemas"]["Cyborgs.Conditions.Condition_Actor"];
        "Cyborgs.Conditions.Fixable": components["schemas"]["Cyborgs.Conditions.Condition_BodyPart"];
        "Cyborgs.Conditions.Pain": components["schemas"]["Cyborgs.Conditions.Condition_BodyPart"];
        "Cyborgs.Conditions.Repairable": components["schemas"]["Cyborgs.Conditions.Condition_BodyPart"];
        "Cyborgs.Conditions.Replaceable": components["schemas"]["Cyborgs.Conditions.Condition_BodyPart"];
        "Cyborgs.Conditions.Shock": components["schemas"]["Cyborgs.Conditions.Condition_BodyPart"];
        "Cyborgs.Conditions.Treatable": components["schemas"]["Cyborgs.Conditions.Condition_BodyPart"];
        "Cyborgs.Conditions.Unconscious": components["schemas"]["Cyborgs.Conditions.Condition_Actor"];
        "Cyborgs.Conditions.Unusable": components["schemas"]["Cyborgs.Conditions.Condition_BodyPart"];
        "Cyborgs.Injury": {
            id: string;
            bodyPartType: components["schemas"]["Cyborgs.BodyPartType"];
            /** Format: int32 */
            severity: number;
        } & components["schemas"]["RpgLifecycleObject"];
        "Cyborgs.MeleeWeapon": {
            readonly damage: components["schemas"]["Values.Dice"];
            /** Format: int32 */
            readonly hitBonus: number;
        } & components["schemas"]["RpgEntity"];
        "Cyborgs.PlayerCharacter": components["schemas"]["Cyborgs.Actor"];
        "Cyborgs.RangedWeapon": {
            readonly damage: components["schemas"]["Values.Dice"];
            /** Format: int32 */
            readonly hitBonus: number;
        } & components["schemas"]["RpgEntity"];
        "Cyborgs.Skills.Combat.Aim": components["schemas"]["Cyborgs.Skills.Skill"];
        "Cyborgs.Skills.Movement.Run": components["schemas"]["Cyborgs.Skills.Skill"];
        "Cyborgs.Skills.Skill": {
            readonly id: string;
            readonly name: string;
            readonly classification: string;
            readonly ownerId: string;
            readonly ownerArchetype: string;
            readonly actionArgs: (components["schemas"]["Reflection.Args.DefaultArg"] | components["schemas"]["Reflection.Args.DiceArg"] | components["schemas"]["Reflection.Args.IntegerArg"] | components["schemas"]["Reflection.Args.RpgObjectArg"])[];
            canPerformMethod: components["schemas"]["Reflection.RpgMethod_ActionTemplate_Boolean"];
            costMethod: components["schemas"]["Reflection.RpgMethod_ActionTemplate_Boolean"];
            performMethod: components["schemas"]["Reflection.RpgMethod_ActionTemplate_Boolean"];
            outcomeMethod: components["schemas"]["Reflection.RpgMethod_ActionTemplate_Boolean"];
            readonly isPerformable: boolean;
            /** Format: int32 */
            rating: number;
            readonly isIntrinsic: boolean;
        };
        "Cyborgs.States.Aiming": components["schemas"]["States.State_Actor"];
        "Cyborgs.States.Exhausted": components["schemas"]["States.State_Actor"];
        "Cyborgs.States.Firing": components["schemas"]["States.State_RangedWeapon"];
        "Cyborgs.States.MeleeAttacked": components["schemas"]["States.State_Actor"];
        "Cyborgs.States.MeleeAttacking": components["schemas"]["States.State_Actor"];
        "Cyborgs.States.Moving": components["schemas"]["States.State_Actor"];
        "Cyborgs.States.Parrying": components["schemas"]["States.State_Actor"];
        "Cyborgs.States.RangedAttacking": components["schemas"]["States.State_Actor"];
        "Cyborgs.States.VeryFast": components["schemas"]["States.State_Actor"];
        "Mods.Mod": {
            expiry: components["schemas"]["Time.LifecycleExpiry"];
            id: string;
            readonly ownerId?: string | null;
            readonly entityId: string;
            readonly prop: string;
            readonly name: string;
            readonly behavior: components["schemas"]["Behaviors.Add"] | components["schemas"]["Behaviors.Combine"] | components["schemas"]["Behaviors.ExpiresOn"] | components["schemas"]["Behaviors.Highest"] | components["schemas"]["Behaviors.Replace"] | components["schemas"]["Behaviors.Threshold"];
            readonly target: components["schemas"]["Props.PropRef"];
            readonly source?: components["schemas"]["Props.PropRef"] | null;
            readonly sourceValue?: components["schemas"]["Values.Dice"] | null;
            readonly isBaseInitMod: boolean;
            readonly isBaseOverrideMod: boolean;
            readonly isBaseMod: boolean;
            readonly isApplied: boolean;
            readonly isDisabled: boolean;
            readonly isActive: boolean;
            readonly isPending: boolean;
            readonly isExpired: boolean;
        };
        /** @enum {string} */
        "Mods.ModScope": "Standard" | "ChildComponents" | "ChildObjects";
        "Mods.ModSet": {
            readonly id: string;
            ownerId?: string | null;
            name: string;
            readonly isApplied: boolean;
            readonly isDisabled: boolean;
            readonly isActive: boolean;
            readonly mods: (components["schemas"]["Mods.Mods.Base"] | components["schemas"]["Mods.Mods.Encounter"] | components["schemas"]["Mods.Mods.Initial"] | components["schemas"]["Mods.Mods.Override"] | components["schemas"]["Mods.Mods.Permanent"] | components["schemas"]["Mods.Mods.Synced"] | components["schemas"]["Mods.Mods.Threshold"] | components["schemas"]["Mods.Mods.Turn"])[];
        } & components["schemas"]["RpgLifecycleObject"];
        "Mods.ModSetDescription": {
            name: string;
            readonly values: {
                [key: string]: components["schemas"]["Values.Dice"];
            };
        };
        "Mods.ModSets.StateModSet": {
            stateName: string;
            instanceType: components["schemas"]["States.StateInstanceType"];
        } & components["schemas"]["Mods.ModSet"];
        "Mods.ModSets.SyncedModSet": {
            syncedToId: string;
        } & components["schemas"]["Mods.ModSet"];
        "Mods.ModSets.TimedModSet": components["schemas"]["Mods.ModSet"];
        "Mods.ModSets.TurnModSet": components["schemas"]["Mods.ModSets.TimedModSet"];
        "Mods.Mods.Base": components["schemas"]["Mods.Mods.Permanent"];
        "Mods.Mods.Encounter": components["schemas"]["Mods.Mods.Time"];
        "Mods.Mods.Initial": components["schemas"]["Mods.Mod"];
        "Mods.Mods.Override": components["schemas"]["Mods.Mod"];
        "Mods.Mods.Permanent": components["schemas"]["Mods.Mod"];
        "Mods.Mods.Synced": components["schemas"]["Mods.Mod"];
        "Mods.Mods.Threshold": components["schemas"]["Mods.Mod"];
        "Mods.Mods.Time": {
            expiry: components["schemas"]["Time.LifecycleExpiry"];
            id: string;
            readonly ownerId?: string | null;
            readonly entityId: string;
            readonly prop: string;
            readonly name: string;
            readonly behavior: components["schemas"]["Behaviors.Add"] | components["schemas"]["Behaviors.Combine"] | components["schemas"]["Behaviors.ExpiresOn"] | components["schemas"]["Behaviors.Highest"] | components["schemas"]["Behaviors.Replace"] | components["schemas"]["Behaviors.Threshold"];
            readonly target: components["schemas"]["Props.PropRef"];
            readonly source?: components["schemas"]["Props.PropRef"] | null;
            readonly sourceValue?: components["schemas"]["Values.Dice"] | null;
            readonly isBaseInitMod: boolean;
            readonly isBaseOverrideMod: boolean;
            readonly isBaseMod: boolean;
            readonly isApplied: boolean;
            readonly isDisabled: boolean;
            readonly isActive: boolean;
            readonly isPending: boolean;
            readonly isExpired: boolean;
        };
        "Mods.Mods.Turn": components["schemas"]["Mods.Mods.Time"];
        "Props.ModDescription": {
            sourceProp?: components["schemas"]["Props.PropDescription"] | null;
            modType: string;
            behavior: string;
            sourceValue?: components["schemas"]["Values.Dice"] | null;
            value: components["schemas"]["Values.Dice"];
            valueFunction?: string | null;
        };
        "Props.Prop": {
            readonly entityId: string;
            readonly name: string;
            refType: components["schemas"]["Props.RefType"];
            readonly mods: (components["schemas"]["Mods.Mods.Base"] | components["schemas"]["Mods.Mods.Encounter"] | components["schemas"]["Mods.Mods.Initial"] | components["schemas"]["Mods.Mods.Override"] | components["schemas"]["Mods.Mods.Permanent"] | components["schemas"]["Mods.Mods.Synced"] | components["schemas"]["Mods.Mods.Threshold"] | components["schemas"]["Mods.Mods.Turn"])[];
            readonly refs: components["schemas"]["Props.PropObjRef"][];
        } & components["schemas"]["RpgLifecycleObject"];
        "Props.PropDescription": {
            rootEntityId: string;
            rootEntityName: string;
            rootEntityArchetype: string;
            rootProp: string;
            entityId: string;
            entityName: string;
            entityArchetype: string;
            prop: string;
            value: components["schemas"]["Values.Dice"];
            baseValue: components["schemas"]["Values.Dice"];
            mods: components["schemas"]["Props.ModDescription"][];
        };
        "Props.PropObjRef": {
            entityId: string;
            ownerId?: string | null;
        } & components["schemas"]["RpgLifecycleObject"];
        "Props.PropRef": {
            entityId: string;
            prop: string;
        };
        /** @enum {string} */
        "Props.RefType": "Value" | "Child" | "Children";
        "Reflection.Args.DefaultArg": components["schemas"]["Reflection.Args.RpgArg"];
        "Reflection.Args.DiceArg": components["schemas"]["Reflection.Args.RpgArg"];
        "Reflection.Args.IntegerArg": components["schemas"]["Reflection.Args.RpgArg"];
        "Reflection.Args.RpgArg": {
            readonly name: string;
            readonly type: string;
            readonly isNullable: boolean;
            readonly value?: unknown;
            readonly groups: string[];
        };
        "Reflection.Args.RpgObjectArg": components["schemas"]["Reflection.Args.RpgArg"];
        "Reflection.RpgMethod_ActionTemplate_Boolean": {
            readonly entityId?: string | null;
            readonly className?: string | null;
            readonly methodName: string;
            readonly returnTypeName?: string | null;
            readonly returnQualifiedTypeName?: string | null;
            readonly returnIsNullable: boolean;
            readonly args: (components["schemas"]["Reflection.Args.DefaultArg"] | components["schemas"]["Reflection.Args.DiceArg"] | components["schemas"]["Reflection.Args.IntegerArg"] | components["schemas"]["Reflection.Args.RpgObjectArg"])[];
            readonly fullName: string;
            readonly isStatic: boolean;
        };
        RpgComponent: {
            expiry: components["schemas"]["Time.LifecycleExpiry"];
            modSets: {
                [key: string]: components["schemas"]["Mods.ModSet"] | components["schemas"]["Mods.ModSets.StateModSet"] | components["schemas"]["Mods.ModSets.SyncedModSet"] | components["schemas"]["Mods.ModSets.TimedModSet"] | components["schemas"]["Mods.ModSets.TurnModSet"];
            };
            props: {
                [key: string]: components["schemas"]["Props.Prop"];
            };
            states: {
                [key: string]: components["schemas"]["Cyborgs.States.Aiming"] | components["schemas"]["Cyborgs.States.Exhausted"] | components["schemas"]["Cyborgs.States.Firing"] | components["schemas"]["Cyborgs.States.MeleeAttacked"] | components["schemas"]["Cyborgs.States.MeleeAttacking"] | components["schemas"]["Cyborgs.States.Moving"] | components["schemas"]["Cyborgs.States.Parrying"] | components["schemas"]["Cyborgs.States.RangedAttacking"] | components["schemas"]["Cyborgs.States.VeryFast"] | components["schemas"]["Cyborgs.Conditions.Attachable"] | components["schemas"]["Cyborgs.Conditions.Bleeding"] | components["schemas"]["Cyborgs.Conditions.Dead"] | components["schemas"]["Cyborgs.Conditions.Dying"] | components["schemas"]["Cyborgs.Conditions.Fixable"] | components["schemas"]["Cyborgs.Conditions.Pain"] | components["schemas"]["Cyborgs.Conditions.Repairable"] | components["schemas"]["Cyborgs.Conditions.Replaceable"] | components["schemas"]["Cyborgs.Conditions.Shock"] | components["schemas"]["Cyborgs.Conditions.Treatable"] | components["schemas"]["Cyborgs.Conditions.Unconscious"] | components["schemas"]["Cyborgs.Conditions.Unusable"];
            };
            readonly id: string;
            readonly ownerId?: string | null;
            readonly archetype: string;
            readonly name: string;
            readonly archetypes: string[];
        };
        RpgContainer: {
            readonly contents: (components["schemas"]["Cyborgs.Armour"] | components["schemas"]["Cyborgs.BodyPart"] | components["schemas"]["Cyborgs.MeleeWeapon"] | components["schemas"]["Cyborgs.PlayerCharacter"] | components["schemas"]["Cyborgs.RangedWeapon"] | components["schemas"]["Cyborgs.Components.PropValue"] | components["schemas"]["RpgContainer"] | components["schemas"]["Activities.Action"] | components["schemas"]["Activities.Activity"])[];
        } & components["schemas"]["RpgComponent"];
        RpgEntity: {
            expiry: components["schemas"]["Time.LifecycleExpiry"];
            modSets: {
                [key: string]: components["schemas"]["Mods.ModSet"] | components["schemas"]["Mods.ModSets.StateModSet"] | components["schemas"]["Mods.ModSets.SyncedModSet"] | components["schemas"]["Mods.ModSets.TimedModSet"] | components["schemas"]["Mods.ModSets.TurnModSet"];
            };
            props: {
                [key: string]: components["schemas"]["Props.Prop"];
            };
            states: {
                [key: string]: components["schemas"]["Cyborgs.States.Aiming"] | components["schemas"]["Cyborgs.States.Exhausted"] | components["schemas"]["Cyborgs.States.Firing"] | components["schemas"]["Cyborgs.States.MeleeAttacked"] | components["schemas"]["Cyborgs.States.MeleeAttacking"] | components["schemas"]["Cyborgs.States.Moving"] | components["schemas"]["Cyborgs.States.Parrying"] | components["schemas"]["Cyborgs.States.RangedAttacking"] | components["schemas"]["Cyborgs.States.VeryFast"] | components["schemas"]["Cyborgs.Conditions.Attachable"] | components["schemas"]["Cyborgs.Conditions.Bleeding"] | components["schemas"]["Cyborgs.Conditions.Dead"] | components["schemas"]["Cyborgs.Conditions.Dying"] | components["schemas"]["Cyborgs.Conditions.Fixable"] | components["schemas"]["Cyborgs.Conditions.Pain"] | components["schemas"]["Cyborgs.Conditions.Repairable"] | components["schemas"]["Cyborgs.Conditions.Replaceable"] | components["schemas"]["Cyborgs.Conditions.Shock"] | components["schemas"]["Cyborgs.Conditions.Treatable"] | components["schemas"]["Cyborgs.Conditions.Unconscious"] | components["schemas"]["Cyborgs.Conditions.Unusable"];
            };
            readonly id: string;
            readonly ownerId?: string | null;
            readonly archetype: string;
            readonly name: string;
            readonly archetypes: string[];
            readonly actionTemplates: {
                [key: string]: components["schemas"]["Cyborgs.Skills.Movement.Run"] | components["schemas"]["Cyborgs.Skills.Combat.Aim"] | components["schemas"]["Cyborgs.Actions.ArmourCheck"] | components["schemas"]["Cyborgs.Actions.MeleeAttack"] | components["schemas"]["Cyborgs.Actions.MeleeParry"] | components["schemas"]["Cyborgs.Actions.RangedAttack"] | components["schemas"]["Cyborgs.Actions.TakeDamage"] | components["schemas"]["Cyborgs.Actions.TakeInjury"] | components["schemas"]["Cyborgs.Actions.Transfer"];
            };
        };
        RpgGraphState: {
            entities: (components["schemas"]["Cyborgs.Armour"] | components["schemas"]["Cyborgs.BodyPart"] | components["schemas"]["Cyborgs.MeleeWeapon"] | components["schemas"]["Cyborgs.PlayerCharacter"] | components["schemas"]["Cyborgs.RangedWeapon"] | components["schemas"]["Cyborgs.Components.PropValue"] | components["schemas"]["RpgContainer"] | components["schemas"]["Activities.Action"] | components["schemas"]["Activities.Activity"])[];
            contextId?: string | null;
            initiatorId?: string | null;
            time?: components["schemas"]["Time.Temporal"] | null;
        };
        RpgLifecycleObject: {
            expiry: components["schemas"]["Time.LifecycleExpiry"];
        };
        RpgObject: {
            expiry: components["schemas"]["Time.LifecycleExpiry"];
            modSets: {
                [key: string]: components["schemas"]["Mods.ModSet"] | components["schemas"]["Mods.ModSets.StateModSet"] | components["schemas"]["Mods.ModSets.SyncedModSet"] | components["schemas"]["Mods.ModSets.TimedModSet"] | components["schemas"]["Mods.ModSets.TurnModSet"];
            };
            props: {
                [key: string]: components["schemas"]["Props.Prop"];
            };
            states: {
                [key: string]: components["schemas"]["Cyborgs.States.Aiming"] | components["schemas"]["Cyborgs.States.Exhausted"] | components["schemas"]["Cyborgs.States.Firing"] | components["schemas"]["Cyborgs.States.MeleeAttacked"] | components["schemas"]["Cyborgs.States.MeleeAttacking"] | components["schemas"]["Cyborgs.States.Moving"] | components["schemas"]["Cyborgs.States.Parrying"] | components["schemas"]["Cyborgs.States.RangedAttacking"] | components["schemas"]["Cyborgs.States.VeryFast"] | components["schemas"]["Cyborgs.Conditions.Attachable"] | components["schemas"]["Cyborgs.Conditions.Bleeding"] | components["schemas"]["Cyborgs.Conditions.Dead"] | components["schemas"]["Cyborgs.Conditions.Dying"] | components["schemas"]["Cyborgs.Conditions.Fixable"] | components["schemas"]["Cyborgs.Conditions.Pain"] | components["schemas"]["Cyborgs.Conditions.Repairable"] | components["schemas"]["Cyborgs.Conditions.Replaceable"] | components["schemas"]["Cyborgs.Conditions.Shock"] | components["schemas"]["Cyborgs.Conditions.Treatable"] | components["schemas"]["Cyborgs.Conditions.Unconscious"] | components["schemas"]["Cyborgs.Conditions.Unusable"];
            };
            readonly id: string;
            readonly ownerId?: string | null;
            readonly archetype: string;
            readonly name: string;
            readonly archetypes: string[];
        };
        /** @enum {string} */
        "Server.Ops.ActionStep": "Cost" | "Perform" | "Outcome";
        "Server.Ops.ActionStepArgs": {
            activityId: string;
            actionStep: components["schemas"]["Server.Ops.ActionStep"];
        };
        "Server.Ops.ActionStepRun": {
            activityId: string;
            args: (components["schemas"]["Reflection.Args.DefaultArg"] | components["schemas"]["Reflection.Args.DiceArg"] | components["schemas"]["Reflection.Args.IntegerArg"] | components["schemas"]["Reflection.Args.RpgObjectArg"])[];
        };
        "Server.Ops.ActivityComplete": {
            activityId: string;
        };
        "Server.Ops.DescribeModSet": {
            entityId: string;
            modSetId: string;
        };
        "Server.Ops.DescribeProp": {
            entityId: string;
            prop: string;
        };
        "Server.Ops.DescribeState": {
            entityId: string;
            state: string;
        };
        "Server.Ops.InitiateAction": {
            initiatorId: string;
            actionTemplateOwnerId: string;
            actionTemplateName: string;
        };
        "Server.Ops.OverrideBaseValue": {
            propRef: components["schemas"]["Props.PropRef"];
            /** Format: int32 */
            value: number;
        };
        "Server.Ops.SetState": {
            entityId: string;
            state: string;
            on: boolean;
        };
        "Server.RpgContent": {
            /** Format: uuid */
            key: string;
            system: string;
            archetype: string;
            name: string;
        };
        "Server.RpgRequest_ActionStepArgs": {
            graphState: components["schemas"]["RpgGraphState"];
            op: components["schemas"]["Server.Ops.ActionStepArgs"];
        };
        "Server.RpgRequest_ActionStepRun": {
            graphState: components["schemas"]["RpgGraphState"];
            op: components["schemas"]["Server.Ops.ActionStepRun"];
        };
        "Server.RpgRequest_ActivityComplete": {
            graphState: components["schemas"]["RpgGraphState"];
            op: components["schemas"]["Server.Ops.ActivityComplete"];
        };
        "Server.RpgRequest_DescribeModSet": {
            graphState: components["schemas"]["RpgGraphState"];
            op: components["schemas"]["Server.Ops.DescribeModSet"];
        };
        "Server.RpgRequest_DescribeProp": {
            graphState: components["schemas"]["RpgGraphState"];
            op: components["schemas"]["Server.Ops.DescribeProp"];
        };
        "Server.RpgRequest_DescribeState": {
            graphState: components["schemas"]["RpgGraphState"];
            op: components["schemas"]["Server.Ops.DescribeState"];
        };
        "Server.RpgRequest_InitiateAction": {
            graphState: components["schemas"]["RpgGraphState"];
            op: components["schemas"]["Server.Ops.InitiateAction"];
        };
        "Server.RpgRequest_ModSet": {
            graphState: components["schemas"]["RpgGraphState"];
            op?: (components["schemas"]["Mods.ModSet"] | components["schemas"]["Mods.ModSets.StateModSet"] | components["schemas"]["Mods.ModSets.SyncedModSet"] | components["schemas"]["Mods.ModSets.TimedModSet"] | components["schemas"]["Mods.ModSets.TurnModSet"]) | null;
        };
        "Server.RpgRequest_OverrideBaseValue": {
            graphState: components["schemas"]["RpgGraphState"];
            op: components["schemas"]["Server.Ops.OverrideBaseValue"];
        };
        "Server.RpgRequest_PointInTime": {
            graphState: components["schemas"]["RpgGraphState"];
            op: components["schemas"]["Time.PointInTime"];
        };
        "Server.RpgRequest_SetState": {
            graphState: components["schemas"]["RpgGraphState"];
            op: components["schemas"]["Server.Ops.SetState"];
        };
        "Server.RpgResponse_Action": {
            graphState: components["schemas"]["RpgGraphState"];
            data?: components["schemas"]["Activities.Action"] | null;
        };
        "Server.RpgResponse_Activity": {
            graphState: components["schemas"]["RpgGraphState"];
            data?: components["schemas"]["Activities.Activity"] | null;
        };
        "Server.RpgResponse_Boolean": {
            graphState: components["schemas"]["RpgGraphState"];
            data: boolean;
        };
        "Server.RpgResponse_ModSetDescription": {
            graphState: components["schemas"]["RpgGraphState"];
            data?: components["schemas"]["Mods.ModSetDescription"] | null;
        };
        "Server.RpgResponse_PointInTime": {
            graphState: components["schemas"]["RpgGraphState"];
            data: components["schemas"]["Time.PointInTime"];
        };
        "Server.RpgResponse_PropDescription": {
            graphState: components["schemas"]["RpgGraphState"];
            data?: components["schemas"]["Props.PropDescription"] | null;
        };
        "Server.RpgResponse_RpgArg[]": {
            graphState: components["schemas"]["RpgGraphState"];
            data?: (components["schemas"]["Reflection.Args.DefaultArg"] | components["schemas"]["Reflection.Args.DiceArg"] | components["schemas"]["Reflection.Args.IntegerArg"] | components["schemas"]["Reflection.Args.RpgObjectArg"])[] | null;
        };
        "Server.RpgResponse_String": {
            graphState: components["schemas"]["RpgGraphState"];
            data?: string | null;
        };
        "States.StateActivation": {
            instanceType: components["schemas"]["States.StateInstanceType"];
            initiatorId?: string | null;
        } & components["schemas"]["Time.Lifespan"];
        /** @enum {string} */
        "States.StateInstanceType": "Manual" | "Conditional" | "Timed";
        "States.StateRef": {
            ownerId: string;
            state: string;
            lifespan: components["schemas"]["Time.Lifespan"] | components["schemas"]["States.StateActivation"];
        };
        "States.State_Actor": {
            expiry: components["schemas"]["Time.LifecycleExpiry"];
            readonly id: string;
            readonly name: string;
            readonly classification: string;
            readonly ownerId: string;
            readonly ownerArchetype?: string | null;
            readonly isPlayerVisible: boolean;
            readonly isOn: boolean;
            readonly isOnTimed: boolean;
            readonly isOnManually: boolean;
            readonly isOnConditionally: boolean;
        };
        "States.State_RangedWeapon": {
            expiry: components["schemas"]["Time.LifecycleExpiry"];
            readonly id: string;
            readonly name: string;
            readonly classification: string;
            readonly ownerId: string;
            readonly ownerArchetype?: string | null;
            readonly isPlayerVisible: boolean;
            readonly isOn: boolean;
            readonly isOnTimed: boolean;
            readonly isOnManually: boolean;
            readonly isOnConditionally: boolean;
        };
        /** @enum {string} */
        "Time.LifecycleExpiry": "Unset" | "Pending" | "Active" | "Expired" | "Destroyed";
        "Time.Lifespan": {
            readonly start: components["schemas"]["Time.PointInTime"];
            readonly end: components["schemas"]["Time.PointInTime"];
            readonly expired?: components["schemas"]["Time.PointInTime"] | null;
            expiry: components["schemas"]["Time.LifecycleExpiry"];
        };
        "Time.PointInTime": {
            type: components["schemas"]["Time.PointInTimeType"];
            /** Format: int32 */
            count: number;
            readonly isEncounterTime: boolean;
            readonly isAfterEncounterTime: boolean;
        };
        /** @enum {string} */
        "Time.PointInTimeType": "BeforeTime" | "TimeBegins" | "Waiting" | "EncounterBegins" | "Turn" | "EncounterEnds" | "TimePasses" | "TimeEnds";
        "Time.Temporal": {
            readonly now: components["schemas"]["Time.PointInTime"];
        };
        "Umbraco.Cms.Api.Management.ViewModels.NotificationHeaderModel": {
            message: string;
            category: string;
            type: components["schemas"]["Umbraco.Cms.Core.Events.EventMessageType"];
        };
        /** @enum {string} */
        "Umbraco.Cms.Core.Events.EventMessageType": "Default" | "Info" | "Error" | "Success" | "Warning";
        "Values.Dice": {
            readonly isConstant: boolean;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export type operations = Record<string, never>;
